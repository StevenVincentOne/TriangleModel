"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Point_1 = require("./Point");
var Line_1 = require("./Line");
var Size_1 = require("./Size");
var prop = function (name) { return function (obj) { return obj[name]; }; };
var Box = /** @class */ (function () {
    function Box(origin, size) {
        this.origin = origin;
        this.size = size;
        Object.freeze(this);
    }
    Object.defineProperty(Box.prototype, "x", {
        get: function () {
            return this.origin.x;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box.prototype, "y", {
        get: function () {
            return this.origin.y;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box.prototype, "width", {
        get: function () {
            return this.size.width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box.prototype, "height", {
        get: function () {
            return this.size.height;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box.prototype, "center", {
        get: function () {
            return this.origin.add(new Point_1.default(this.size.width / 2, this.size.height / 2));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box.prototype, "bound", {
        get: function () {
            return this.origin.add(new Point_1.default(this.size.width, this.size.height));
        },
        enumerable: true,
        configurable: true
    });
    Box.prototype.corners = function () {
        var topLeft = this.origin, topRight = topLeft.add(new Point_1.default(this.width, 0)), bottomRight = topRight.add(new Point_1.default(0, this.height)), bottomLeft = topLeft.add(new Point_1.default(0, this.height));
        return [topLeft, topRight, bottomRight, bottomLeft];
    };
    Object.defineProperty(Box.prototype, "crosshair", {
        // @TODO: Move to Point
        get: function () {
            var center = this.center;
            return [
                new Line_1.default(new Point_1.default(-Infinity, center.y), new Point_1.default(Infinity, center.y)),
                new Line_1.default(new Point_1.default(center.x, -Infinity), new Point_1.default(center.x, Infinity))
            ];
        },
        enumerable: true,
        configurable: true
    });
    Box.prototype.pad = function (size) {
        return new Box(this.origin.add(new Point_1.default(-size, -size)), this.size.add(new Size_1.default(size, size)));
    };
    // @TODO: Determine some kind of generalized algorthim for closed list walking
    Box.prototype.edges = function () {
        return this.corners().reduce(function (prev, cur, idx, array) {
            if (!prev.last) {
                prev.last = cur;
                return prev;
            }
            prev.push(new Line_1.default(prev.last, cur));
            if (idx === array.length - 1)
                prev.push(new Line_1.default(cur, array[0]));
            return prev;
        }, []);
    };
    Box.prototype.contains = function (point) {
        return ((this.x <= point.x && point.x <= (this.x + this.width)) &&
            (this.y <= point.y && point.y <= (this.y + this.height)));
    };
    Object.defineProperty(Box.prototype, "overlaps", {
        get: function () {
            var _this = this;
            return function (box) {
                var p1 = _this.origin, p2 = _this.bound, p3 = box.origin, p4 = box.bound;
                return !(p2.y < p3.y || p1.y > p4.y || p2.x < p3.x || p1.x > p4.x);
            };
        },
        enumerable: true,
        configurable: true
    });
    Box.prototype.toPairs = function () {
        return [this.origin.x, this.origin.y, this.size.width, this.size.height];
    };
    Box.bound = function (boxes) {
        var o = boxes.map(prop('origin')), b = boxes.map(prop('bound'));
        var origins = { x: o.map(prop('x')), y: o.map(prop('y')) };
        var bounds = { x: b.map(prop('x')), y: b.map(prop('y')) };
        var x = Math.min.apply(Math, origins.x), y = Math.min.apply(Math, origins.y), width = Math.max.apply(Math, bounds.x) - x, height = Math.max.apply(Math, bounds.y) - y;
        return Box.fromPairs(x, y, width, height);
    };
    Box.fromPairs = function (x, y, width, height) {
        return new Box(new Point_1.default(x, y), new Size_1.default(width, height));
    };
    return Box;
}());
exports.default = Box;
//# sourceMappingURL=Box.js.map